local Player = game.Players.LocalPlayer
local Mouse = Player:GetMouse()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local PlacementService = require(ReplicatedStorage:WaitForChild("PlacementService"))
local PlaceEvent = ReplicatedStorage:WaitForChild("PlaceItemEvent")

local currentTool, ghostModel = nil, nil
local isPlacing, rotation, lastPlaceTime = false, 0, 0 
local MAX_DISTANCE, GRID_SIZE = 40, 4
local RED_COLOR, GREEN_COLOR = Color3.fromRGB(255, 50, 50), Color3.fromRGB(50, 255, 50)

local cachedTargets = {}
local lastTargetCFrame = CFrame.new()
local isTweening = false 

local detector = Instance.new("Part")
detector.Transparency = 1
detector.CanCollide = false
detector.CanQuery = false 
detector.Anchored = true
detector.Size = Vector3.new(GRID_SIZE * 4, 6, GRID_SIZE * 4) 

local function setGhostAttributes(model)
	if not model then return end
	for _, part in ipairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide, part.CanQuery, part.CanTouch, part.CastShadow = false, false, false, false
			part.Transparency = 0.5
			if part:IsA("UnionOperation") then part.UsePartColor = true end
		end
	end
end

local function cleanup()
	isPlacing = false
	if ghostModel then ghostModel:Destroy() ghostModel = nil end
	currentTool = nil
	cachedTargets = {}
	lastTargetCFrame = CFrame.new()
	isTweening = false
end

local function getTargetParts(isStructure)
	local targets = {}
	local folder = workspace:FindFirstChild("CustomTerrain")
	local structures = workspace:FindFirstChild("PlacedStructures")

	if folder then
		for _, item in ipairs(folder:GetChildren()) do
			if isStructure then
				if item.Name == "Foundation" or item:GetAttribute("Structure") then
					table.insert(targets, item)
				end
			else
				if item.Name == "Grass" or item.Name == "Foundation" then
					table.insert(targets, item)
				end
			end
		end
	end

	if structures then
		for _, item in ipairs(structures:GetDescendants()) do
			if item:IsA("BasePart") then
				if isStructure and (item.Name == "Foundation" or item:GetAttribute("Structure")) then
					table.insert(targets, item)
				end
			end
		end
	end
	return targets
end

local function setup(char)
	char.ChildAdded:Connect(function(c)
		if c:IsA("Tool") and c:GetAttribute("Place") then
			cleanup()
			currentTool = c
			isPlacing = true
			ghostModel = PlacementService.CreateGhostFromTool(c)
			ghostModel.Parent = workspace
			setGhostAttributes(ghostModel)
			cachedTargets = getTargetParts(currentTool:GetAttribute("Structure") or false)
			c.Unequipped:Connect(cleanup)
		end
	end)
end

RunService.RenderStepped:Connect(function()
	if not isPlacing or not currentTool or not ghostModel or not Player.Character then return end

	local sx = currentTool:GetAttribute("SizeX") or 1
	local sy = currentTool:GetAttribute("SizeY") or 1
	local yOffsetAttr = currentTool:GetAttribute("Offset") or 0
	local isStructure = currentTool:GetAttribute("Structure") or false
	local isFoundation = (currentTool.Name == "Foundation")
	local isWall = (currentTool.Name == "Wall")

	local worldWidth = (rotation % 180 ~= 0) and sy or sx
	local worldDepth = (rotation % 180 ~= 0) and sx or sy

	local params = RaycastParams.new()
	params.FilterDescendantsInstances = cachedTargets
	params.FilterType = Enum.RaycastFilterType.Include 

	local mouseRay = workspace:Raycast(Mouse.UnitRay.Origin, Mouse.UnitRay.Direction * 1000, params)
	if not mouseRay then return end

	local activeGrid = GRID_SIZE
	if not isStructure and mouseRay.Instance.Name == "Foundation" then
		activeGrid = 2 
	end

	local function getSnap(pos, size, customGrid)
		local g = customGrid or activeGrid
		return (size % 2 ~= 0) and math.round(pos / g) * g or (math.floor(pos / g) * g) + (g / 2)
	end

	local snappedX = getSnap(mouseRay.Position.X, worldWidth)
	local snappedZ = getSnap(mouseRay.Position.Z, worldDepth)
	local currentRotation = rotation
	local maxHeight = -math.huge
	local isBlocked = false
	local isSnappedToNeighbor = false

	local ghostPivot, modelSize = ghostModel:GetBoundingBox()

	if isWall then
		local hitPart = mouseRay.Instance
		local localPos = hitPart.CFrame:PointToObjectSpace(mouseRay.Position)
		local halfHit = hitPart.Size / 2
		local halfWall = modelSize / 2

		if math.abs(localPos.X/halfHit.X) > math.abs(localPos.Z/halfHit.Z) then
			local side = math.sign(localPos.X)
			localPos = Vector3.new(side * (halfHit.X - halfWall.X), 0, 0)
			currentRotation = (side > 0) and 90 or -90
		else
			local side = math.sign(localPos.Z)
			localPos = Vector3.new(0, 0, side * (halfHit.Z - halfWall.Z))
			currentRotation = (side > 0) and 180 or 0
		end
		local worldPos = hitPart.CFrame:PointToWorldSpace(localPos)
		snappedX, snappedZ = worldPos.X, worldPos.Z
		maxHeight = hitPart.Position.Y + (hitPart.Size.Y / 2)
	elseif isStructure and not isFoundation then
		snappedX = getSnap(mouseRay.Position.X, worldWidth, 2)
		snappedZ = getSnap(mouseRay.Position.Z, worldDepth, 2)
		maxHeight = mouseRay.Instance.Position.Y + (mouseRay.Instance.Size.Y / 2)
	else
		detector.Position = Vector3.new(snappedX, mouseRay.Position.Y, snappedZ)
		local overlapParams = OverlapParams.new()
		overlapParams.FilterType = Enum.RaycastFilterType.Include
		overlapParams.FilterDescendantsInstances = {workspace}

		local snapHeight = nil
		local overlappingParts = workspace:GetPartsInPart(detector, overlapParams)

		local closestDist = math.huge
		local bestPart = nil

		if isFoundation then
			for _, part in ipairs(overlappingParts) do
				if part.Name == "Foundation" then
					local dist = (part.Position - detector.Position).Magnitude
					if dist < closestDist then
						closestDist = dist
						bestPart = part
					end
				end
			end

			if bestPart then
				local lPos = bestPart.CFrame:PointToObjectSpace(mouseRay.Position)
				local totalOffset = 1 * GRID_SIZE 
				local oX, oZ = 0, 0
				if math.abs(lPos.X) > math.abs(lPos.Z) then
					oX = math.sign(lPos.X) * totalOffset
				else
					oZ = math.sign(lPos.Z) * totalOffset
				end
				snappedX = bestPart.Position.X + oX
				snappedZ = bestPart.Position.Z + oZ
				snapHeight = bestPart.Position.Y + (bestPart.Size.Y / 2)
				isSnappedToNeighbor = true
			end
		end

		local startX, startZ = snappedX - (worldWidth * activeGrid / 2), snappedZ - (worldDepth * activeGrid / 2)
		local tilesFound = 0

		for x = 0, sx - 1 do
			for z = 0, sy - 1 do
				local cx, cz = startX + (x * activeGrid) + (activeGrid / 2), startZ + (z * activeGrid) + (activeGrid / 2)
				local ray = workspace:Raycast(Vector3.new(cx, 500, cz), Vector3.new(0, -1000, 0), params)
				if ray then
					tilesFound += 1
					if not snapHeight and ray.Position.Y > maxHeight then maxHeight = ray.Position.Y end
					if isFoundation then
						if ray.Instance.Name == "Foundation" then isBlocked = true end
						if ray.Instance.Name == "Grass" and ray.Instance:GetAttribute("Occupied") then isBlocked = true end
					end
				end
			end
		end
		if snapHeight then maxHeight = snapHeight end
		if tilesFound < (sx * sy) then isBlocked = true end
	end

	local antiClipOffset = (isSnappedToNeighbor) and 0 or (isStructure and -0.05 or 0.01)
	local finalPos = Vector3.new(snappedX, maxHeight + (modelSize.Y / 2) + yOffsetAttr + antiClipOffset, snappedZ)
	local targetCFrame = CFrame.new(finalPos) * CFrame.Angles(0, math.rad(currentRotation), 0)

	if (targetCFrame.Position - lastTargetCFrame.Position).Magnitude > 0.1 or rotation ~= currentRotation then
		lastTargetCFrame = targetCFrame
		isTweening = true
		local tInfo = TweenInfo.new(0.05, Enum.EasingStyle.Linear)
		local tPart = ghostModel.PrimaryPart or ghostModel:FindFirstChildWhichIsA("BasePart")

		if tPart then
			local tween = TweenService:Create(tPart, tInfo, {CFrame = targetCFrame})
			tween.Completed:Connect(function() isTweening = false end)
			tween:Play()
		else
			ghostModel:PivotTo(targetCFrame)
			isTweening = false
		end
	end

	if isStructure and not isBlocked then
		local overlapParams = OverlapParams.new()
		overlapParams.FilterDescendantsInstances = {ghostModel, Player.Character}
		overlapParams.FilterType = Enum.RaycastFilterType.Exclude
		local collisions = workspace:GetPartBoundsInBox(targetCFrame, modelSize * 0.9, overlapParams)
		for _, part in ipairs(collisions) do
			if part:GetAttribute("Structure") or part.Name == "Wall" then 
				isBlocked = true 
				break 
			end
		end
	end

	if (Player.Character.HumanoidRootPart.Position - finalPos).Magnitude > MAX_DISTANCE then isBlocked = true end
	local ghostColor = (not isBlocked) and GREEN_COLOR or RED_COLOR
	for _, p in pairs(ghostModel:GetDescendants()) do if p:IsA("BasePart") then p.Color = ghostColor end end
	ghostModel:SetAttribute("CanPlace", not isBlocked)
end)

UserInputService.InputBegan:Connect(function(i, p)
	if p or not isPlacing or not currentTool then return end
	if i.KeyCode == Enum.KeyCode.R then rotation = (rotation + 90) % 360 end
	if i.UserInputType == Enum.UserInputType.MouseButton1 then
		if tick() - lastPlaceTime < 0.2 then return end 
		if ghostModel and ghostModel:GetAttribute("CanPlace") and not isTweening then
			lastPlaceTime = tick()
			PlaceEvent:FireServer(currentTool, ghostModel:GetPivot())
			task.delay(0.1, function()
				if currentTool then
					cachedTargets = getTargetParts(currentTool:GetAttribute("Structure") or false)
				end
			end)
		end
	end
end)

if Player.Character then setup(Player.Character) end
Player.CharacterAdded:Connect(setup)
