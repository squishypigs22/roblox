local Player = game.Players.LocalPlayer
local Mouse = Player:GetMouse()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")

local PlacementService = require(ReplicatedStorage:WaitForChild("PlacementService"))
local PlaceEvent = ReplicatedStorage:WaitForChild("PlaceItemEvent")

local GRID_SIZE = 4
local MAX_DISTANCE = 50
local SMOOTH_ALPHA = 0.35
local PLACE_COOLDOWN = 0.2

local GREEN = Color3.fromRGB(50, 255, 50)
local RED = Color3.fromRGB(255, 50, 50)

local currentTool = nil
local ghostModel = nil
local isPlacing = false
local rotation = 0
local lastPlaceTime = 0
local renderConn = nil

local currentTargetCF = CFrame.new()
local smoothedCF = CFrame.new()

local function getFolders()
	return workspace:FindFirstChild("CustomTerrain"), workspace:FindFirstChild("PlacedStructures")
end

local function setGhostVisual(model)
	for _, part in ipairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide = false
			part.CanQuery = false
			part.CanTouch = false
			part.CastShadow = false
			part.Transparency = 0.5
		end
	end
end

local function colorGhost(model, color)
	for _, part in ipairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Color = color
		end
	end
end

local function getRotatedFootprint(tool, yaw)
	local sx = tool:GetAttribute("SizeX") or 1
	local sy = tool:GetAttribute("SizeY") or 1
	if yaw % 180 ~= 0 then
		return sy, sx
	end
	return sx, sy
end

local function snapToGrid(value)
	return math.round(value / GRID_SIZE) * GRID_SIZE
end

local function getSupportHeightAt(x, z)
	local terrainFolder, structuresFolder = getFolders()
	if not terrainFolder then
		return nil, nil
	end

	local include = { terrainFolder }
	if structuresFolder then
		table.insert(include, structuresFolder)
	end

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = include

	local hit = workspace:Raycast(Vector3.new(x, 500, z), Vector3.new(0, -1200, 0), params)
	if not hit then
		return nil, nil
	end

	return hit.Position.Y, hit.Instance
end

local function snapOnFoundationEdge(hitPart, hitPos, modelSize, toolName)
	local localPos = hitPart.CFrame:PointToObjectSpace(hitPos)
	local halfHit = hitPart.Size / 2
	local halfModel = modelSize / 2
	local topY = hitPart.Position.Y + halfHit.Y

	if toolName == "Wall" then
		if math.abs(localPos.X / halfHit.X) > math.abs(localPos.Z / halfHit.Z) then
			local side = math.sign(localPos.X)
			local x = hitPart.Position.X + side * (halfHit.X - halfModel.X)
			return Vector3.new(x, topY + halfModel.Y, hitPart.Position.Z), (side > 0) and 90 or -90
		else
			local side = math.sign(localPos.Z)
			local z = hitPart.Position.Z + side * (halfHit.Z - halfModel.Z)
			return Vector3.new(hitPart.Position.X, topY + halfModel.Y, z), (side > 0) and 180 or 0
		end
	end

	if math.abs(localPos.X / halfHit.X) > math.abs(localPos.Z / halfHit.Z) then
		local side = math.sign(localPos.X)
		local x = hitPart.Position.X + side * (halfHit.X + halfModel.X)
		return Vector3.new(x, topY + halfModel.Y, hitPart.Position.Z), rotation
	else
		local side = math.sign(localPos.Z)
		local z = hitPart.Position.Z + side * (halfHit.Z + halfModel.Z)
		return Vector3.new(hitPart.Position.X, topY + halfModel.Y, z), rotation
	end
end

local function getPlacementTarget()
	local terrainFolder, structuresFolder = getFolders()
	if not terrainFolder or not ghostModel or not currentTool then
		return nil, true
	end

	local include = { terrainFolder }
	if structuresFolder then
		table.insert(include, structuresFolder)
	end

	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Include
	rayParams.FilterDescendantsInstances = include

	local mouseRay = workspace:Raycast(Mouse.UnitRay.Origin, Mouse.UnitRay.Direction * 1000, rayParams)
	if not mouseRay then
		return nil, true
	end

	local isStructure = currentTool:GetAttribute("Structure") or false
	local isFoundation = currentTool.Name == "Foundation"
	local yOffset = currentTool:GetAttribute("Offset") or 0
	local modelSize = ghostModel:GetExtentsSize()

	local targetYaw = rotation
	local finalPos = nil

	if mouseRay.Instance.Name == "Foundation" then
		finalPos, targetYaw = snapOnFoundationEdge(mouseRay.Instance, mouseRay.Position, modelSize, currentTool.Name)
		finalPos = finalPos + Vector3.new(0, yOffset, 0)
	elseif not isStructure or isFoundation then
		local snappedX = snapToGrid(mouseRay.Position.X)
		local snappedZ = snapToGrid(mouseRay.Position.Z)
		local supportY = getSupportHeightAt(snappedX, snappedZ)
		if not supportY then
			return nil, true
		end
		finalPos = Vector3.new(snappedX, supportY + (modelSize.Y / 2) + yOffset, snappedZ)
	else
		return nil, true
	end

	local targetCF = CFrame.new(finalPos) * CFrame.Angles(0, math.rad(targetYaw), 0)
	return targetCF, false
end

local function footprintSupported(targetCF)
	local terrainFolder, structuresFolder = getFolders()
	if not terrainFolder then
		return false
	end

	local include = { terrainFolder }
	if structuresFolder then
		table.insert(include, structuresFolder)
	end

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = include

	local sx, sy = getRotatedFootprint(currentTool, rotation)
	local startX = targetCF.Position.X - (sx * GRID_SIZE / 2)
	local startZ = targetCF.Position.Z - (sy * GRID_SIZE / 2)

	for x = 0, sx - 1 do
		for z = 0, sy - 1 do
			local cx = startX + (x * GRID_SIZE) + (GRID_SIZE / 2)
			local cz = startZ + (z * GRID_SIZE) + (GRID_SIZE / 2)
			local hit = workspace:Raycast(Vector3.new(cx, targetCF.Position.Y + 200, cz), Vector3.new(0, -400, 0), params)
			if not hit then
				return false
			end
			if hit.Instance:GetAttribute("Occupied") == true then
				return false
			end
		end
	end

	return true
end

local function isBlockedAt(targetCF)
	if not currentTool or not ghostModel or not Player.Character then
		return true
	end

	local hrp = Player.Character:FindFirstChild("HumanoidRootPart")
	if not hrp then
		return true
	end

	if (hrp.Position - targetCF.Position).Magnitude > MAX_DISTANCE then
		return true
	end

	local overlapParams = OverlapParams.new()
	overlapParams.FilterType = Enum.RaycastFilterType.Exclude
	overlapParams.FilterDescendantsInstances = { Player.Character, ghostModel }

	local modelSize = ghostModel:GetExtentsSize()
	local isStructure = currentTool:GetAttribute("Structure") or false
	local hits = workspace:GetPartBoundsInBox(targetCF, modelSize * 0.95, overlapParams)
	for _, part in ipairs(hits) do
		if part.Name ~= "Ocean" and part.Transparency < 0.98 then
			if isStructure and part.Name == "Foundation" then
				-- allowed support contact
			elseif part.Name ~= "Grass" and part.Name ~= "Sand" then
				return true
			end
		end
	end

	if (currentTool.Name == "Foundation") then
		if not footprintSupported(targetCF) then
			return true
		end
	end

	return false
end

local function stopRenderLoop()
	if renderConn then
		renderConn:Disconnect()
		renderConn = nil
	end
end

local function cleanup()
	stopRenderLoop()
	isPlacing = false
	currentTool = nil
	if ghostModel then
		ghostModel:Destroy()
		ghostModel = nil
	end
end

local function startPlacement(tool)
	cleanup()
	currentTool = tool
	isPlacing = true
	ghostModel = PlacementService.CreateGhostFromTool(tool)
	ghostModel.Parent = workspace
	setGhostVisual(ghostModel)
	currentTargetCF = ghostModel:GetPivot()
	smoothedCF = currentTargetCF

	renderConn = RunService.RenderStepped:Connect(function()
		if not isPlacing or not currentTool or not ghostModel then
			return
		end

		local targetCF, invalid = getPlacementTarget()
		if invalid or not targetCF then
			ghostModel:SetAttribute("CanPlace", false)
			colorGhost(ghostModel, RED)
			return
		end

		currentTargetCF = targetCF
		smoothedCF = smoothedCF:Lerp(currentTargetCF, SMOOTH_ALPHA)
		if ghostModel and ghostModel.Parent then
			ghostModel:PivotTo(smoothedCF)
		end

		local blocked = isBlockedAt(currentTargetCF)
		ghostModel:SetAttribute("CanPlace", not blocked)
		colorGhost(ghostModel, blocked and RED or GREEN)
	end)

	tool.Unequipped:Connect(function()
		cleanup()
	end)
end

local function setupCharacter(char)
	char.ChildAdded:Connect(function(child)
		if child:IsA("Tool") and child:GetAttribute("Place") then
			startPlacement(child)
		end
	end)

	for _, child in ipairs(char:GetChildren()) do
		if child:IsA("Tool") and child:GetAttribute("Place") then
			startPlacement(child)
			break
		end
	end
end

UserInputService.InputBegan:Connect(function(input, processed)
	if processed or not isPlacing or not currentTool or not ghostModel then
		return
	end

	if input.KeyCode == Enum.KeyCode.R then
		rotation = (rotation + 90) % 360
	end

	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		if tick() - lastPlaceTime < PLACE_COOLDOWN then
			return
		end
		if ghostModel:GetAttribute("CanPlace") then
			lastPlaceTime = tick()
			PlaceEvent:FireServer(currentTool, currentTargetCF, rotation)
		end
	end
end)

if Player.Character then
	setupCharacter(Player.Character)
end
Player.CharacterAdded:Connect(setupCharacter)
