local Player = game.Players.LocalPlayer
local Mouse = Player:GetMouse()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local PlacementService = require(ReplicatedStorage:WaitForChild("PlacementService"))
local PlaceEvent = ReplicatedStorage:WaitForChild("PlaceItemEvent")

local currentTool, ghostModel = nil, nil
local isPlacing, rotation, lastPlaceTime = false, 0, 0 
local MAX_DISTANCE, GRID_SIZE = 40, 4
local RED_COLOR, GREEN_COLOR = Color3.fromRGB(255, 50, 50), Color3.fromRGB(50, 255, 50)

local cachedTargets = {}
local lastTargetCFrame = CFrame.new()
local isTweening = false 

local detector = Instance.new("Part")
detector.Transparency = 1
detector.CanCollide = false
detector.CanQuery = false 
detector.Anchored = true
detector.Size = Vector3.new(GRID_SIZE * 0.9, 6, GRID_SIZE * 0.9) 

-- Helper: Find closest socket and enforce height locking
local function getClosestSocket(hitPart, socketName, mousePosition)
	local socketsFolder = hitPart:FindFirstChild("Sockets")
	if not socketsFolder then return nil end

	local closestSocket = nil
	local shortestDist = math.huge

	for _, socket in ipairs(socketsFolder:GetChildren()) do
		if socket:IsA("Attachment") and socket.Name == socketName then
			local dist = (Vector2.new(socket.WorldPosition.X, socket.WorldPosition.Z) - Vector2.new(mousePosition.X, mousePosition.Z)).Magnitude
			if dist < shortestDist then
				shortestDist = dist
				closestSocket = socket
			end
		end
	end
	return closestSocket
end

local function setGhostAttributes(model)
	if not model then return end
	for _, part in ipairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide, part.CanQuery, part.CanTouch, part.CastShadow = false, false, false, false
			part.Transparency = 0.5
			if part:IsA("UnionOperation") then part.UsePartColor = true end
		end
	end
end

local function cleanup()
	isPlacing = false
	if ghostModel then ghostModel:Destroy() ghostModel = nil end
	currentTool = nil
	cachedTargets = {}
	lastTargetCFrame = CFrame.new()
	isTweening = false
end

local function getTargetParts(isStructure)
	local targets = {}
	for _, item in ipairs(workspace:GetDescendants()) do
		if item:IsA("BasePart") then
			if isStructure then
				if item.Name == "Foundation" or item:GetAttribute("Structure") then
					table.insert(targets, item)
				end
			else
				if item.Name == "Grass" or item.Name == "Foundation" then
					table.insert(targets, item)
				end
			end
		end
	end
	return targets
end

local function setup(char)
	char.ChildAdded:Connect(function(c)
		if c:IsA("Tool") and c:GetAttribute("Place") then
			cleanup()
			currentTool = c
			isPlacing = true
			ghostModel = PlacementService.CreateGhostFromTool(c)
			ghostModel.Parent = workspace
			setGhostAttributes(ghostModel)
			cachedTargets = getTargetParts(currentTool:GetAttribute("Structure") or false)
			c.Unequipped:Connect(cleanup)
		end
	end)
end

RunService.RenderStepped:Connect(function()
	if not isPlacing or not currentTool or not ghostModel or not Player.Character then return end

	local sx = currentTool:GetAttribute("SizeX") or 1
	local sy = currentTool:GetAttribute("SizeY") or 1
	local yOffsetAttr = currentTool:GetAttribute("Offset") or 0
	local isStructure = currentTool:GetAttribute("Structure") or false
	local isFoundation = (currentTool.Name == "Foundation")
	local isWall = (currentTool.Name == "Wall")

	local worldWidth = (rotation % 180 ~= 0) and sy or sx
	local worldDepth = (rotation % 180 ~= 0) and sx or sy

	local params = RaycastParams.new()
	params.FilterDescendantsInstances = cachedTargets
	params.FilterType = Enum.RaycastFilterType.Include 

	local mouseRay = workspace:Raycast(Mouse.UnitRay.Origin, Mouse.UnitRay.Direction * 1000, params)
	if not mouseRay then return end

	local hitPart = mouseRay.Instance
	local targetCFrame = CFrame.new()
	local isBlocked = false
	local maxHeight = -math.huge
	local _, modelSize = ghostModel:GetBoundingBox()

	-- GRID SNAPPING LOGIC
	local activeGrid = (not isStructure and hitPart.Name == "Foundation") and 2 or GRID_SIZE
	local function getSnap(pos, size, g)
		return (size % 2 ~= 0) and math.round(pos / g) * g or (math.floor(pos / g) * g) + (g / 2)
	end

	local snappedX = getSnap(mouseRay.Position.X, worldWidth, activeGrid)
	local snappedZ = getSnap(mouseRay.Position.Z, worldDepth, activeGrid)
	local finalRotation = rotation

	if isWall then
		local socket = getClosestSocket(hitPart, "WallSocket", mouseRay.Position)
		if socket then
			targetCFrame = socket.WorldCFrame * CFrame.new(0, (modelSize.Y / 2) + yOffsetAttr, 0)
		else
			isBlocked = true 
		end
	elseif isFoundation then
		-- Neighbor Snapping via Sockets
		local socket = getClosestSocket(hitPart, "FoundationSocket", mouseRay.Position)
		if socket then
			targetCFrame = socket.WorldCFrame
			maxHeight = socket.WorldPosition.Y
		else
			-- Manual Foundation on Grass
			maxHeight = mouseRay.Position.Y
			targetCFrame = CFrame.new(snappedX, maxHeight + (modelSize.Y / 2) + yOffsetAttr, snappedZ) * CFrame.Angles(0, math.rad(rotation), 0)
		end
	else
		-- General Structures / Decor
		maxHeight = hitPart.Position.Y + (hitPart.Size.Y / 2)
		targetCFrame = CFrame.new(snappedX, maxHeight + (modelSize.Y / 2) + yOffsetAttr, snappedZ) * CFrame.Angles(0, math.rad(rotation), 0)
	end

	-- HEIGHT LOCKING: Prevent sliding down the side of blocks
	if isFoundation and not isBlocked then
		detector.Position = targetCFrame.Position
		local op = OverlapParams.new()
		op.FilterDescendantsInstances = {workspace}
		op.FilterType = Enum.RaycastFilterType.Include

		local parts = workspace:GetPartsInPart(detector, op)
		for _, p in ipairs(parts) do
			if p.Name == "Foundation" and p ~= ghostModel then
				isBlocked = true -- Prevent clipping into other foundations
			end
		end
	end

	-- Smooth Tweening
	if (targetCFrame.Position - lastTargetCFrame.Position).Magnitude > 0.1 or rotation ~= finalRotation then
		lastTargetCFrame = targetCFrame
		isTweening = true
		local tPart = ghostModel.PrimaryPart or ghostModel:FindFirstChildWhichIsA("BasePart")
		if tPart then
			local tween = TweenService:Create(tPart, TweenInfo.new(0.08, Enum.EasingStyle.Cubic), {CFrame = targetCFrame})
			tween.Completed:Connect(function() isTweening = false end)
			tween:Play()
		else
			ghostModel:PivotTo(targetCFrame)
			isTweening = false
		end
	end

	-- ANTI-CLIP & OCCUPANCY
	if not isBlocked then
		local overlapParams = OverlapParams.new()
		overlapParams.FilterDescendantsInstances = {ghostModel, Player.Character}
		overlapParams.FilterType = Enum.RaycastFilterType.Exclude
		local collisions = workspace:GetPartBoundsInBox(targetCFrame, modelSize * 0.95, overlapParams)
		for _, part in ipairs(collisions) do
			if part:GetAttribute("Structure") or part.Name == "Wall" then 
				isBlocked = true break 
			end
		end
	end

	if (Player.Character.HumanoidRootPart.Position - targetCFrame.Position).Magnitude > MAX_DISTANCE then isBlocked = true end

	local ghostColor = (not isBlocked) and GREEN_COLOR or RED_COLOR
	for _, p in pairs(ghostModel:GetDescendants()) do if p:IsA("BasePart") then p.Color = ghostColor end end
	ghostModel:SetAttribute("CanPlace", not isBlocked)

	-- Update global reference for firing event
	_G.FinalTargetCFrame = targetCFrame 
end)

UserInputService.InputBegan:Connect(function(i, p)
	if p or not isPlacing or not currentTool then return end
	if i.KeyCode == Enum.KeyCode.R then rotation = (rotation + 90) % 360 end
	if i.UserInputType == Enum.UserInputType.MouseButton1 then
		if tick() - lastPlaceTime < 0.2 then return end 
		if ghostModel and ghostModel:GetAttribute("CanPlace") and not isTweening then
			lastPlaceTime = tick()
			PlaceEvent:FireServer(currentTool, _G.FinalTargetCFrame)
		end
	end
end)

if Player.Character then setup(Player.Character) end
Player.CharacterAdded:Connect(setup)
