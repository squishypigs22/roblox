local Player = game.Players.LocalPlayer
local Mouse = Player:GetMouse()
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local TweenService = game:GetService("TweenService")

local PlacementService = require(ReplicatedStorage:WaitForChild("PlacementService"))
local PlaceEvent = ReplicatedStorage:WaitForChild("PlaceItemEvent")

local currentTool, ghostModel = nil, nil
local isPlacing, rotation, lastPlaceTime = false, 0, 0

local GRID_SIZE = 4
local MAX_DISTANCE = 50
local RED_COLOR = Color3.fromRGB(255, 50, 50)
local GREEN_COLOR = Color3.fromRGB(50, 255, 50)

local lastTargetCFrame = CFrame.new()
local isTweening = false

local function getFolders()
	local terrain = workspace:FindFirstChild("CustomTerrain")
	local structures = workspace:FindFirstChild("PlacedStructures")
	return terrain, structures
end

local function setGhostAttributes(model)
	if not model then
		return
	end

	for _, part in ipairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.CanCollide = false
			part.CanQuery = false
			part.CanTouch = false
			part.CastShadow = false
			part.Transparency = 0.5
		end
	end
end

local function paintGhost(model, color)
	for _, part in ipairs(model:GetDescendants()) do
		if part:IsA("BasePart") then
			part.Color = color
		end
	end
end

local function cleanup()
	isPlacing = false
	if ghostModel then
		ghostModel:Destroy()
		ghostModel = nil
	end
	currentTool = nil
	isTweening = false
	lastTargetCFrame = CFrame.new()
end

local function snapToGrid(value)
	return math.round(value / GRID_SIZE) * GRID_SIZE
end

local function getStructureSnapSocket(hitPosition)
	local _, structuresFolder = getFolders()
	if not structuresFolder then
		return nil
	end

	local overlapParams = OverlapParams.new()
	overlapParams.FilterType = Enum.RaycastFilterType.Include
	overlapParams.FilterDescendantsInstances = { structuresFolder }

	local nearbyParts = workspace:GetPartBoundsInBox(CFrame.new(hitPosition), Vector3.new(16, 12, 16), overlapParams)

	local bestAttachment, bestDistance = nil, math.huge
	for _, part in ipairs(nearbyParts) do
		if part.Name == "Foundation" then
			local sockets = part:FindFirstChild("Sockets")
			if sockets then
				for _, socket in ipairs(sockets:GetChildren()) do
					if socket:IsA("Attachment") then
						local worldPos = socket.WorldPosition
						local d = (worldPos - hitPosition).Magnitude
						if d < bestDistance then
							bestDistance = d
							bestAttachment = socket
						end
					end
				end
			end
		end
	end

	if bestDistance <= 10 then
		return bestAttachment
	end

	return nil
end

local function getTerrainHeightAt(x, z)
	local terrainFolder = getFolders()
	if not terrainFolder then
		return nil, nil
	end

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = { terrainFolder }

	local ray = workspace:Raycast(Vector3.new(x, 500, z), Vector3.new(0, -1200, 0), params)
	if not ray then
		return nil, nil
	end

	return ray.Position.Y, ray.Instance
end

local function setup(char)
	char.ChildAdded:Connect(function(child)
		if child:IsA("Tool") and child:GetAttribute("Place") then
			cleanup()
			currentTool = child
			isPlacing = true
			ghostModel = PlacementService.CreateGhostFromTool(child)
			ghostModel.Parent = workspace
			setGhostAttributes(ghostModel)
			child.Unequipped:Connect(cleanup)
		end
	end)
end

RunService.RenderStepped:Connect(function()
	if not isPlacing or not currentTool or not ghostModel or not Player.Character then
		return
	end

	local terrainFolder, structuresFolder = getFolders()
	if not terrainFolder then
		return
	end

	local isFoundation = currentTool.Name == "Foundation"
	local isStructure = currentTool:GetAttribute("Structure") or false
	local yOffset = currentTool:GetAttribute("Offset") or 0

	local include = { terrainFolder }
	if structuresFolder then
		table.insert(include, structuresFolder)
	end

	local rayParams = RaycastParams.new()
	rayParams.FilterType = Enum.RaycastFilterType.Include
	rayParams.FilterDescendantsInstances = include

	local mouseRay = workspace:Raycast(Mouse.UnitRay.Origin, Mouse.UnitRay.Direction * 1000, rayParams)
	if not mouseRay then
		return
	end

	local modelSize = ghostModel:GetExtentsSize()
	local targetCF
	local blocked = false

	if isStructure and not isFoundation then
		local socket = getStructureSnapSocket(mouseRay.Position)
		if socket then
			local base = socket.WorldPosition
			local yawByName = { North = 180, South = 0, East = 90, West = -90 }
			local yaw = yawByName[socket.Name] or rotation
			local finalPos = Vector3.new(base.X, base.Y + (modelSize.Y / 2) + yOffset, base.Z)
			targetCF = CFrame.new(finalPos) * CFrame.Angles(0, math.rad(yaw), 0)
		else
			blocked = true
			targetCF = CFrame.new(mouseRay.Position)
		end
	else
		local snappedX = snapToGrid(mouseRay.Position.X)
		local snappedZ = snapToGrid(mouseRay.Position.Z)
		local topY = getTerrainHeightAt(snappedX, snappedZ)
		if not topY then
			blocked = true
			topY = mouseRay.Position.Y
		end

		local finalPos = Vector3.new(snappedX, topY + (modelSize.Y / 2) + yOffset, snappedZ)
		targetCF = CFrame.new(finalPos) * CFrame.Angles(0, math.rad(rotation), 0)
	end

	if (targetCF.Position - lastTargetCFrame.Position).Magnitude > 0.05 then
		lastTargetCFrame = targetCF
		isTweening = true

		local tweenProxy = Instance.new("CFrameValue")
		tweenProxy.Value = ghostModel:GetPivot()
		local connection
		connection = tweenProxy:GetPropertyChangedSignal("Value"):Connect(function()
			ghostModel:PivotTo(tweenProxy.Value)
		end)

		local tween = TweenService:Create(tweenProxy, TweenInfo.new(0.05, Enum.EasingStyle.Linear), { Value = targetCF })
		tween.Completed:Connect(function()
			isTweening = false
			connection:Disconnect()
			tweenProxy:Destroy()
		end)
		tween:Play()
	end

	if Player.Character:FindFirstChild("HumanoidRootPart") then
		if (Player.Character.HumanoidRootPart.Position - targetCF.Position).Magnitude > MAX_DISTANCE then
			blocked = true
		end
	end

	if structuresFolder and isStructure then
		local overlapParams = OverlapParams.new()
		overlapParams.FilterType = Enum.RaycastFilterType.Include
		overlapParams.FilterDescendantsInstances = { structuresFolder }
		local collisions = workspace:GetPartBoundsInBox(targetCF, modelSize * 0.9, overlapParams)
		for _, part in ipairs(collisions) do
			if part.Name ~= "Foundation" then
				blocked = true
				break
			end
		end
	end

	ghostModel:SetAttribute("CanPlace", not blocked)
	paintGhost(ghostModel, (not blocked) and GREEN_COLOR or RED_COLOR)
end)

UserInputService.InputBegan:Connect(function(input, processed)
	if processed or not isPlacing or not currentTool then
		return
	end

	if input.KeyCode == Enum.KeyCode.R then
		rotation = (rotation + 90) % 360
	end

	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		if tick() - lastPlaceTime < 0.2 then
			return
		end

		if ghostModel and ghostModel:GetAttribute("CanPlace") and not isTweening then
			lastPlaceTime = tick()
			PlaceEvent:FireServer(currentTool, ghostModel:GetPivot())
		end
	end
end)

if Player.Character then
	setup(Player.Character)
end
Player.CharacterAdded:Connect(setup)
