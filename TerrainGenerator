local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local islandRadius = 200
local maxHeight = 18
local landBlockSize = 4
local chunkSize = 32
local floorY = -20
local seaCullY = -10

local baseLandColor = Color3.fromRGB(46, 139, 87)
local sandColor = Color3.fromRGB(194, 178, 128)

local landNoiseScale = 0.007
local detailNoiseScale = 0.05

local treeProbability = 0.03
local stoneProbability = 0.005
local minTreeDistance = 40
local minStoneDistance = 40

local decorActiveRadius = 140

local function generateSeed()
	return math.random(1, 1000000)
end

local seed = generateSeed()
local shapeSeed = generateSeed()
math.randomseed(seed)

local function getHeight(x, z)
	local distance = math.sqrt(x * x + z * z)
	local angle = math.atan2(z, x)

	local radiusWarp = math.noise(math.cos(angle) * 1.8, math.sin(angle) * 1.8, shapeSeed) * 70
	local adjustedRadius = islandRadius + radiusWarp
	local distFromEdge = adjustedRadius - distance

	if distFromEdge < -10 then
		return nil
	end

	local falloff = math.clamp(distFromEdge / 40, 0, 1)
	local n1 = math.noise(x * landNoiseScale, z * landNoiseScale, seed)
	local n2 = math.noise(x * detailNoiseScale, z * detailNoiseScale, seed + 1) * 0.2

	local height = ((n1 + n2) * maxHeight) * falloff
	height += (falloff * 8)

	if distFromEdge > 40 then
		height = math.max(height, 2)
	end

	return math.floor(height)
end

local function getMaterialAndColor(x, z)
	local distance = math.sqrt(x * x + z * z)
	local angle = math.atan2(z, x)
	local radiusWarp = math.noise(math.cos(angle) * 1.8, math.sin(angle) * 1.8, shapeSeed) * 70
	local adjustedRadius = islandRadius + radiusWarp
	local distFromEdge = adjustedRadius - distance

	if distFromEdge < 14 then
		return Enum.Material.Sand, sandColor, "Sand"
	end

	return Enum.Material.SmoothPlastic, baseLandColor, "Grass"
end

local function createBlock(terrainFolder, position, topHeight)
	if topHeight < seaCullY then
		return nil
	end

	local material, color, name = getMaterialAndColor(position.X, position.Z)
	local blockHeight = math.max(1, topHeight - floorY)
	local centerY = floorY + (blockHeight / 2)

	local block = Instance.new("Part")
	block.Name = name
	block.Size = Vector3.new(landBlockSize, blockHeight, landBlockSize)
	block.Position = Vector3.new(position.X, centerY, position.Z)
	block.Anchored = true
	block.Material = material
	block.Color = color
	block.TopSurface = Enum.SurfaceType.Smooth
	block.BottomSurface = Enum.SurfaceType.Smooth
	block.CanCollide = true
	block.CanQuery = true
	block:SetAttribute("Occupied", false)
	block.Parent = terrainFolder


	return block
end

local function setDecorActive(model, isActive)
	for _, desc in ipairs(model:GetDescendants()) do
		if desc:IsA("BasePart") then
			desc.CanCollide = isActive
			desc.CanQuery = isActive
		end
	end
end

local function placeDecorInChunk(blocksInChunk, treesFolder, stonesFolder)
	local treeSource = ReplicatedStorage:FindFirstChild("Trees")
	local stoneSource = ReplicatedStorage:FindFirstChild("Stones")
	if not treeSource or not stoneSource then
		return
	end

	local function tryPlace(items, probability, minDistance, parentFolder)
		local children = items:GetChildren()
		if #children == 0 then
			return
		end

		local spots = {}

		for _, block in ipairs(blocksInChunk) do
			local topY = block.Position.Y + (block.Size.Y / 2)
			if block.Name == "Grass" and topY >= 1 and math.random() < probability then
				local tooClose = false
				for _, pos in ipairs(spots) do
					if (block.Position - pos).Magnitude < minDistance then
						tooClose = true
						break
					end
				end

				if not tooClose then
					local model = children[math.random(1, #children)]:Clone()
					model:PivotTo(CFrame.new(Vector3.new(block.Position.X, topY, block.Position.Z)) * CFrame.Angles(0, math.rad(math.random(0, 360)), 0))
					model.Parent = parentFolder
					setDecorActive(model, false)
					table.insert(spots, block.Position)
				end
			end
		end
	end

	tryPlace(treeSource, treeProbability, minTreeDistance, treesFolder)
	tryPlace(stoneSource, stoneProbability, minStoneDistance, stonesFolder)
end

local function updateDecorPhysics(treesFolder, stonesFolder)
	local function nearestPlayerDistance(position)
		local nearest = math.huge
		for _, player in ipairs(Players:GetPlayers()) do
			local character = player.Character
			local hrp = character and character:FindFirstChild("HumanoidRootPart")
			if hrp then
				local d = (hrp.Position - position).Magnitude
				if d < nearest then
					nearest = d
				end
			end
		end
		return nearest
	end

	for _, folder in ipairs({ treesFolder, stonesFolder }) do
		for _, model in ipairs(folder:GetChildren()) do
			local pivot = model:GetPivot()
			local active = nearestPlayerDistance(pivot.Position) <= decorActiveRadius
			setDecorActive(model, active)
		end
	end
end

local hasTeleported = false
local function teleportPlayers(spawnPos)
	if hasTeleported then
		return
	end
	hasTeleported = true
	task.wait(1)

	for _, player in ipairs(Players:GetPlayers()) do
		local character = player.Character
		local hrp = character and character:FindFirstChild("HumanoidRootPart")
		if hrp then
			hrp.CFrame = CFrame.new(spawnPos + Vector3.new(0, 6, 0))
		end
	end
end

local function generateTerrain()
	local terrainFolder = Instance.new("Folder")
	terrainFolder.Name = "CustomTerrain"
	terrainFolder.Parent = workspace

	local treesFolder = Instance.new("Folder")
	treesFolder.Name = "Trees"
	treesFolder.Parent = workspace

	local stonesFolder = Instance.new("Folder")
	stonesFolder.Name = "Stones"
	stonesFolder.Parent = workspace

	local bounds = islandRadius + 40
	for cx = -bounds, bounds, chunkSize do
		for cz = -bounds, bounds, chunkSize do
			local chunkBlocks = {}
			local hasLand = false

			for x = cx, cx + chunkSize - landBlockSize, landBlockSize do
				for z = cz, cz + chunkSize - landBlockSize, landBlockSize do
					local topHeight = getHeight(x, z)
					if topHeight and topHeight >= seaCullY then
						hasLand = true
						local block = createBlock(terrainFolder, Vector3.new(x, 0, z), topHeight)
						if block then
							table.insert(chunkBlocks, block)
							if not hasTeleported and math.abs(x) < 5 and math.abs(z) < 5 then
								teleportPlayers(Vector3.new(x, topHeight, z))
							end
						end
					end
				end
			end

			if hasLand then
				placeDecorInChunk(chunkBlocks, treesFolder, stonesFolder)
			end

			task.wait()
		end
	end

	task.spawn(function()
		while true do
			updateDecorPhysics(treesFolder, stonesFolder)
			task.wait(1)
		end
	end)
end

local function createWater()
	local water = Instance.new("Part")
	water.Name = "Ocean"
	water.Size = Vector3.new(2000, 2, 2000)
	water.Position = Vector3.new(0, -3.5, 0)
	water.Anchored = true
	water.CanCollide = false
	water.CanQuery = false
	water.Transparency = 0.5
	water.Color = Color3.fromRGB(0, 130, 190)
	water.Material = Enum.Material.Glass
	water.Parent = workspace
end

createWater()
generateTerrain()
