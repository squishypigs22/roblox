local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local PlaceEvent = ReplicatedStorage:WaitForChild("PlaceItemEvent")

local GRID_SIZE = 4
local PLACE_COOLDOWN = 0.2
local MAX_DISTANCE = 55

local itemFolders = {
	ReplicatedStorage:WaitForChild("CraftableItems"),
	ReplicatedStorage:WaitForChild("CraftingBenchItems"),
	ReplicatedStorage:WaitForChild("Resources"),
}

local cooldowns = {}
local occupiedCells = {} -- ["x:z"] = true

local function keyFor(x, z)
	return tostring(x) .. ":" .. tostring(z)
end

local function findModel(name)
	for _, folder in ipairs(itemFolders) do
		local found = folder:FindFirstChild(name)
		if found then
			return found
		end
	end
	return nil
end

local function getRotatedFootprint(tool, yaw)
	local sx = tool:GetAttribute("SizeX") or 1
	local sy = tool:GetAttribute("SizeY") or 1
	if yaw % 180 ~= 0 then
		return sy, sx
	end
	return sx, sy
end

local function claimCells(targetCF, tool, snappedYaw)
	local sx, sy = getRotatedFootprint(tool, snappedYaw)
	local startX = targetCF.Position.X - (sx * GRID_SIZE / 2)
	local startZ = targetCF.Position.Z - (sy * GRID_SIZE / 2)

	for x = 0, sx - 1 do
		for z = 0, sy - 1 do
			local cx = math.floor(startX + (x * GRID_SIZE) + (GRID_SIZE / 2))
			local cz = math.floor(startZ + (z * GRID_SIZE) + (GRID_SIZE / 2))
			occupiedCells[keyFor(cx, cz)] = true
		end
	end
end

local function getYawFromCFrame(cf)
	local _, y, _ = cf:ToOrientation()
	local deg = math.deg(y)
	return math.floor((deg + 45) / 90) * 90
end

local function cellsAreFree(targetCF, tool, yaw)
	local sx, sy = getRotatedFootprint(tool, yaw)
	local startX = targetCF.Position.X - (sx * GRID_SIZE / 2)
	local startZ = targetCF.Position.Z - (sy * GRID_SIZE / 2)

	for x = 0, sx - 1 do
		for z = 0, sy - 1 do
			local cx = math.floor(startX + (x * GRID_SIZE) + (GRID_SIZE / 2))
			local cz = math.floor(startZ + (z * GRID_SIZE) + (GRID_SIZE / 2))
			if occupiedCells[keyFor(cx, cz)] then
				return false
			end
		end
	end

	return true
end

local function edgeSnapOnFoundation(hitPart, hitPos, modelExtents, toolName, requestedYaw)
	local localPos = hitPart.CFrame:PointToObjectSpace(hitPos)
	local halfHit = hitPart.Size / 2
	local halfModel = modelExtents / 2
	local topY = hitPart.Position.Y + halfHit.Y

	if toolName == "Wall" then
		if math.abs(localPos.X / halfHit.X) > math.abs(localPos.Z / halfHit.Z) then
			local side = math.sign(localPos.X)
			local x = hitPart.Position.X + side * (halfHit.X - halfModel.X)
			return CFrame.new(x, topY + halfModel.Y, hitPart.Position.Z) * CFrame.Angles(0, math.rad((side > 0) and 90 or -90), 0), true
		else
			local side = math.sign(localPos.Z)
			local z = hitPart.Position.Z + side * (halfHit.Z - halfModel.Z)
			return CFrame.new(hitPart.Position.X, topY + halfModel.Y, z) * CFrame.Angles(0, math.rad((side > 0) and 180 or 0), 0), true
		end
	end

	if math.abs(localPos.X / halfHit.X) > math.abs(localPos.Z / halfHit.Z) then
		local side = math.sign(localPos.X)
		local x = hitPart.Position.X + side * (halfHit.X + halfModel.X)
		return CFrame.new(x, topY + halfModel.Y, hitPart.Position.Z) * CFrame.Angles(0, math.rad(requestedYaw), 0), true
	else
		local side = math.sign(localPos.Z)
		local z = hitPart.Position.Z + side * (halfHit.Z + halfModel.Z)
		return CFrame.new(hitPart.Position.X, topY + halfModel.Y, z) * CFrame.Angles(0, math.rad(requestedYaw), 0), true
	end
end

local function raycastSupport(x, z, y)
	local terrainFolder = workspace:FindFirstChild("CustomTerrain")
	local structuresFolder = workspace:FindFirstChild("PlacedStructures")
	if not terrainFolder then
		return nil
	end

	local include = { terrainFolder }
	if structuresFolder then
		table.insert(include, structuresFolder)
	end

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Include
	params.FilterDescendantsInstances = include

	return workspace:Raycast(Vector3.new(x, y, z), Vector3.new(0, -1200, 0), params)
end

local function validateSupportAndOccupancy(targetCF, tool, yaw)
	local sx, sy = getRotatedFootprint(tool, yaw)
	local startX = targetCF.Position.X - (sx * GRID_SIZE / 2)
	local startZ = targetCF.Position.Z - (sy * GRID_SIZE / 2)
	local isStructure = tool:GetAttribute("Structure") or false

	for x = 0, sx - 1 do
		for z = 0, sy - 1 do
			local cx = startX + (x * GRID_SIZE) + (GRID_SIZE / 2)
			local cz = startZ + (z * GRID_SIZE) + (GRID_SIZE / 2)
			local hit = raycastSupport(cx, cz, targetCF.Position.Y + 200)
			if not hit then
				return false
			end

			if isStructure then
				if hit.Instance.Name ~= "Foundation" then
					return false
				end
			else
				if hit.Instance:GetAttribute("Occupied") == true then
					return false
				end
			end
		end
	end

	return true
end

local function collides(targetCF, extents, character, isStructure)
	local overlapParams = OverlapParams.new()
	overlapParams.FilterType = Enum.RaycastFilterType.Exclude
	overlapParams.FilterDescendantsInstances = { character }

	local hits = workspace:GetPartBoundsInBox(targetCF, extents * 0.95, overlapParams)
	for _, part in ipairs(hits) do
		if part.Transparency < 0.98 and part.Name ~= "Ocean" then
			if isStructure and part.Name == "Foundation" then
				-- allowed support contact
			elseif part.Name ~= "Grass" and part.Name ~= "Sand" then
				return true
			end
		end
	end
	return false
end

local function finalSnap(tool, requestedCF, requestedYaw, sourceModel)
	local supportHit = raycastSupport(requestedCF.Position.X, requestedCF.Position.Z, 500)
	if not supportHit then
		return nil, requestedYaw
	end

	local extents = sourceModel:IsA("Model") and sourceModel:GetExtentsSize() or sourceModel.Size
	local yOffset = tool:GetAttribute("Offset") or 0
	local isStructure = tool:GetAttribute("Structure") or false
	local isFoundation = tool.Name == "Foundation"

	if supportHit.Instance.Name == "Foundation" then
		local snappedCF = edgeSnapOnFoundation(supportHit.Instance, supportHit.Position, extents, tool.Name, requestedYaw)
		if snappedCF then
			return snappedCF + Vector3.new(0, yOffset, 0), requestedYaw
		end
	end

	if (not isStructure) or isFoundation then
		local gx = math.round(requestedCF.Position.X / GRID_SIZE) * GRID_SIZE
		local gz = math.round(requestedCF.Position.Z / GRID_SIZE) * GRID_SIZE
		local ground = raycastSupport(gx, gz, 500)
		if not ground then
			return nil, requestedYaw
		end
		local y = ground.Position.Y + (extents.Y / 2) + yOffset
		return CFrame.new(gx, y, gz) * CFrame.Angles(0, math.rad(requestedYaw), 0), requestedYaw
	end

	return nil, requestedYaw
end

PlaceEvent.OnServerEvent:Connect(function(player, tool, requestedCF, requestedYaw)
	local now = tick()
	if cooldowns[player] and (now - cooldowns[player]) < PLACE_COOLDOWN then
		return
	end
	cooldowns[player] = now

	if not tool or not tool:IsA("Tool") or typeof(requestedCF) ~= "CFrame" then
		return
	end

	local character = player.Character
	local hrp = character and character:FindFirstChild("HumanoidRootPart")
	if not character or not hrp then
		return
	end

	if tool.Parent ~= character and tool.Parent ~= player:FindFirstChildOfClass("Backpack") then
		return
	end

	if (hrp.Position - requestedCF.Position).Magnitude > MAX_DISTANCE then
		return
	end

	local sourceModel = findModel(tool.Name)
	if not sourceModel then
		return
	end

	local yaw = tonumber(requestedYaw) or 0
	local targetCF = finalSnap(tool, requestedCF, yaw, sourceModel)
	if not targetCF then
		return
	end

	local extents = sourceModel:IsA("Model") and sourceModel:GetExtentsSize() or sourceModel.Size
	local isStructure = tool:GetAttribute("Structure") or false
	if collides(targetCF, extents, character, isStructure) then
		return
	end

	local snappedYaw = getYawFromCFrame(targetCF)
	if not cellsAreFree(targetCF, tool, snappedYaw) then
		return
	end

	if not validateSupportAndOccupancy(targetCF, tool, snappedYaw) then
		return
	end

	local placedItem = sourceModel:Clone()
	if placedItem:IsA("Tool") then
		local model = Instance.new("Model")
		model.Name = tool.Name
		for _, child in ipairs(placedItem:GetChildren()) do
			if child:IsA("BasePart") or child:IsA("Model") then
				child.Parent = model
			end
		end
		placedItem = model
	else
		placedItem.Name = tool.Name
	end

	for _, desc in ipairs(placedItem:GetDescendants()) do
		if desc:IsA("Script") or desc:IsA("LocalScript") then
			desc:Destroy()
		end
	end

	placedItem:PivotTo(targetCF)

	local isFoundation = tool.Name == "Foundation"
	for _, desc in ipairs(placedItem:GetDescendants()) do
		if desc:IsA("BasePart") then
			desc.Anchored = true
			desc.CanCollide = true
			desc.CanQuery = true
			desc:SetAttribute("Occupied", true)
			if isStructure then
				desc:SetAttribute("Structure", true)
			end
			if isFoundation then
				desc.Name = "Foundation"
			end
		end
	end

	local terrainFolder = workspace:FindFirstChild("CustomTerrain")
	if terrainFolder then
		local sx, sy = getRotatedFootprint(tool, snappedYaw)
		local startX = targetCF.Position.X - (sx * GRID_SIZE / 2)
		local startZ = targetCF.Position.Z - (sy * GRID_SIZE / 2)
		for x = 0, sx - 1 do
			for z = 0, sy - 1 do
				local cx = startX + (x * GRID_SIZE) + (GRID_SIZE / 2)
				local cz = startZ + (z * GRID_SIZE) + (GRID_SIZE / 2)
				local hit = raycastSupport(cx, cz, targetCF.Position.Y + 200)
				if hit and hit.Instance and (hit.Instance.Name == "Grass" or hit.Instance.Name == "Sand") then
					hit.Instance:SetAttribute("Occupied", true)
				end
			end
		end
	end

	claimCells(targetCF, tool, snappedYaw)

	local amount = tool:GetAttribute("Amount") or 1
	if amount > 1 then
		tool:SetAttribute("Amount", amount - 1)
	else
		tool:Destroy()
	end

	local container = workspace:FindFirstChild("PlacedStructures")
	if not container then
		container = Instance.new("Folder")
		container.Name = "PlacedStructures"
		container.Parent = workspace
	end
	placedItem.Parent = container
end)

Players.PlayerRemoving:Connect(function(player)
	cooldowns[player] = nil
end)
